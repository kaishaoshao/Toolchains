# kdb

## 引言

项目主要是学习《Building a Debugger》作者 Sy Brand

作者github : https://github.com/TartanLlama

作者相关博客：https://tartanllama.xyz/posts/writing-a-linux-debugger

项目代码仓库：主要是想写一个自己的调试器，如果可以我希望能为在作者的基础上支持riscv架构

作者推荐将调试器设置为一个库，更好的编写自动化测试，并且能开发与调试器交互的应用程序（单线程）

## 常见知识点

### 缩写

| 名称 | 作用 |
| ---- | ---- |
| ABI  |      |
| ASLR |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |
|      |      |

## Chapter 1 : Project Setup

项目设置 引导你完成设置构建调试器的环境

使用cmake

文件结构

```bash
kdb
├── CMakeLists.txt
├── include        对外头文件
│   └── libsdb
├── src
│   ├── CMakeLists.txt
│   └── include    对内头文件
├── test
│   └── CMakeLists.txt
└── tools
|   └── CMakeLists.txt
└── CMakeLists.txt
```

## Chapter 2 : Compilation and Compute architeture

### 第一部分：编译 (Compilation)

这部分解释了我们编写的代码是如何变成计算机可以执行的程序的，以及这个过程如何影响调试器的设计。

1. **编译是一个“有损”过程 (Lossy Process)**
   * **核心概念** ：编译器将我们能读懂的源代码（如 C++）翻译成 CPU 能直接执行的二进制机器码。这个翻译过程是不可逆的，很多源代码中的信息会丢失。
   * **为什么重要** ：编译器不在乎你给变量起的名字是 `database_transaction` 还是 `cat_1`，它可能直接优化掉变量名，甚至变量本身。因此，你不能直接从编译好的程序反推出完美的源代码。
   * **对调试器的意义** ：正是因为编译过程丢失了信息，我们才需要一种方法来“找回”这些信息。这就是“调试信息”的作用。
2. **编码 (Encoding)**
   * **核心概念** ：无论是文本文档还是可执行程序，在计算机里都只是一堆 0 和 1。我们之所以能理解它们，是因为有特定的“编码规则”。文本文件遵循 UTF-8 或 ASCII 编码，而可执行程序在 Linux 上遵循一种叫做 **ELF (Executable and Linkable Format)** 的格式。
   * **为什么重要** ：调试器需要像读一本书一样去“阅读”和“理解”这个 ELF 文件，从中提取所需的信息。
3. **调试信息 (Debug Information)**
   * **核心概念** ：为了弥补编译过程中的信息损失，我们可以让编译器在生成 ELF 文件时，额外附加一个“说明书”，这就是调试信息。在 Linux 上，这个信息的格式叫做  **DWARF** 。
   * **包含哪些信息** ：
   * 源代码文件名和路径。
   * 函数名，以及它在内存中的位置范围。
   * 变量名，以及在程序运行的任何时刻如何找到这个变量（可能在内存里，也可能在寄存器里）。
   * 程序中的数据类型是如何定义的（比如一个类有哪些成员）。
   * **最重要的** ：机器指令和源代码行号之间的对应关系。
   * **对调试器的意义** ：没有 DWARF 信息，调试器就只能显示汇编代码，无法知道当前执行到了源代码的哪一行，也无法按变量名显示变量的值。

### 第二部分：操作系统与调试器 (Operating Systems and Debuggers)

这部分讲解了操作系统（以 Linux 为例）为程序的运行和调试提供了怎样的环境和工具。

1. **程序加载 (Program Loading)**
   * **核心概念** ：当你执行一个程序时，操作系统会读取其 ELF 文件，在内存中为其分配空间，将代码和数据从文件复制到内存，设置好运行环境（比如命令行参数），然后跳转到程序的入口点开始执行。
2. **用户空间 vs. 内核空间 (User Space vs. Kernel Space)**
   * **核心概念** ：操作系统为了安全，将环境分为两个区域。我们平时编写和运行的程序都处于“用户空间”，权限受限，不能直接访问硬件。而操作系统的核心部分运行在“内核空间”，拥有最高权限。
   * **系统调用 (Syscalls)** ：用户空间的程序如果想执行特权操作（如读写文件、分配内存），必须通过一种正式的请求——“系统调用”——来请求内核帮忙完成。
   * **对调试器的意义** ：调试器本质上也是一个用户空间的程序，它要控制另一个程序，就必须使用操作系统提供的特殊系统调用。
3. **虚拟内存 (Virtual Memory)**
   * **核心概念** ：操作系统“欺骗”了每个程序，让它们以为自己独占了一整块连续的内存空间。程序中看到的内存地址（比如 `0xBA5EBA11`）是“虚拟地址”，而不是物理内存条上的真实地址。操作系统和 CPU 硬件会负责将这个虚拟地址翻译成真实地址。
   * **为什么重要** ：
   * **保护性** ：确保一个程序不会意外地读写另一个程序的内存。
   * **灵活性** ：让程序加载和运行变得更简单。
   * **对调试器的意义** ：调试器读取另一个进程的内存时，操作的也是虚拟地址。
4. **调试 API (Debug APIs)**
   * **核心概念** ：为了让调试器能工作，操作系统提供了一套专门的系统调用接口。在 Linux 上，这个核心接口就是  **`ptrace`** 。
   * **`ptrace` 的功能** ：`ptrace` 是一个功能非常强大的系统调用，调试器用它来附加到一个进程、读取/写入内存和寄存器、单步执行指令、接收进程发出的信号等。后续章节中你会大量使用它。
5. **信号 (Signals)**
   * **核心概念** ：信号是 Unix/Linux 系统中一种简单的进程间通信方式，用来通知一个进程发生了某个事件。
   * **常见例子** ：
   * `SIGINT`：当你在终端按下 `Ctrl+C` 时发送，通常用于中断程序。
   * `SIGSEGV`：当程序试图访问无效内存时（段错误），由内核发送。
   * `SIGTRAP`：这是一个特殊的“陷阱”信号，是实现断点的关键。当 CPU 执行到断点指令时，会产生这个信号。
   * **对调试器的意义** ：调试器通过 `ptrace` 监控目标进程，当目标进程收到如 `SIGTRAP` 这样的信号时，它会暂停执行，然后由操作系统通知调试器。这样，调试器就知道断点被触发了。

### 第三部分：计算机体系结构 (Computer Architecture)

这部分介绍了与 CPU 和内存直接相关的底层概念。

1. **寄存器 (Registers)**
   * **核心概念** ：寄存器是 CPU 内部极少量但速度极快的存储单元。可以把硬盘比作仓库，内存比作办公桌，那么寄存器就是你手里的笔和纸，拿取速度最快。
   * **用途** ：用于存放函数参数、返回值、局部变量，以及一些特殊状态信息。
   * **程序计数器 (Program Counter / Instruction Pointer)** ：这是一个最特殊的寄存器（在 x64 架构下叫 `rip`），它永远指向下一条将要被执行的机器指令的内存地址。调试器中的“单步执行”功能，本质上就是在精确地控制这个寄存器。
2. **汇编和指令编码 (Assembly and Instruction Encodings)**
   * **核心概念** ：机器指令本身也是二进制数据，CPU 根据“指令编码”规则来解码并执行它们。汇编语言是这些二进制指令的人类可读的版本。
   * **为什么重要** ：虽然我们大部分时间在源代码层面调试，但理解汇编有助于明白底层到底发生了什么，尤其是在没有调试信息或需要进行内存和反汇编操作时。
3. **字节序 (Endianness)**
   * **核心概念** ：对于跨越多个字节的数据类型（比如一个 4 字节的整数），在内存中存储这些字节有两种顺序：大端序 (Big-Endian) 和小端序 (Little-Endian)。
   * **大端序** ：高位字节存放在低地址（像我们正常书写数字）。
   * **小端序** ：低位字节存放在低地址（顺序是反的）。
   * **为什么重要** ：我们使用的 x64 架构是  **小端序** 。当调试器从内存中读取一个多字节的数字时，必须按照正确的字节序来重新组合它们，否则得到的值就是错误的。
4. **栈帧 (Stack Frames)**
   * **核心概念** ：当一个函数被调用时，它会在一个叫做“栈”的特殊内存区域上创建一个属于自己的小空间，这个空间就叫“栈帧”。
   * **栈帧里有什么** ：
   * 函数的局部变量。
   * 传递给这个函数的参数。
   * **返回地址** ：当函数执行完毕后，程序计数器应该跳回的地址。
   * **工作方式** ：函数调用时，新的栈帧被“压”到栈顶；函数返回时，它的栈帧被“弹”出。这构成了函数调用的链条。
   * **对调试器的意义** ：**回溯 (Backtrace)** 功能——也就是查看函数调用链——的实现原理就是通过分析这些栈帧，逐层向上找到每个函数的返回地址和相关信息。

## Chapter3: ATTACHING TO A PROCESS

### 启动和附加到进程

提供调试器两种附加到进程的方式
